### 프로시저의 실행 단계

------

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
2. 프로시저로 제어를 넘긴다.
3. 프로시저가 사용할 수 있는 메모리 자원을 확보한다.
4. 프로시저를 실행한다.
5. 프로시저를 호출한 프로그램이 접근할 수 있는 곳에 결과값을 넣는다.
6. 프로시저를 호출한 프로그램에게 제어를 넘겨준다.



- MIPS는 다음의 관례에 따라 32개의 레지스터를 할당한다.

  - $a0 - $a3: 인풋 파라미터
  - $v0, $v1: 반환값
  - $ra: 호출한 곳으로 다시 되돌아가기위한 주소

  

### jal 명령어(Jump-and-link instruction)

------

지정된 주소로 jump하고 다음 명령어의 주소를 $ra레지스터에 저장한다.

```jsx
jal addr
```

jump: 지정된 주소로 점프한다.

link: 프로시저 종료 후 프로시저가 호출된 위치로 다시 돌아올 수 있도록 호출한 곳과 프로시저 사이에 링크를 형성한다. 링크는 $ra 레지스터에 저장되며, 저장된 링크를 복귀주소(return address)라고 한다.

```jsx
jr $ra    #$ra에 저장된 주소로 점프하라 
```

호출 프로그램(**caller**)은 $a0 - $a3에 인풋 파라미터를 넣은 후 jr 명령을 통해 피호출 프로그램(**callee**)을 호출한다. 피호출 프로그램(프로시저)는 작업을 수행하고 계산 결과를 $v0, $v1에 넣은 후 ``jr $ra`` 명령을 통해 원래 프로그램으로 복귀한다.

jal 명령은 프로시저에서 복귀할 때 다음 명령어부터 실행하도록 PC+4를 $ra에 저장한다. PC(program counter)란 현재 수행 중인 명령어의 주소를 기억하는 레지스터이다.





### 스택(Stack)

------

스택: 나중에 들어간 값이 먼저 나오는 큐.

스택포인터($sp): 가장 최근에 스택에 할당된 주소를 가리킴. 레지스터 값이 스택에 저장되거나 복구될 때마다 한 워드씩 조정됨.



push: 스택에 데이터 넣기

pop: 스택에서 데이터 빼기



스택은 높은 주소에서 낮은 주소로 성장한다. 따라서 스택에 푸시할 때는 포인터 값을 감소시켜야 하고, 팝을 할 때는 포인터 값을 증가시켜야 한다.



### Example 1

------

```jsx
int leaf_example(int g, int h, int i, ing j)
{
	int f;
	f = (g + h) - (i + j);
	return f;
}
```

파라미터 g, h, i, j는 각각 $a0, $a1, $a2, $a3에 해당하고 f는 $s0에 해당한다.

위 프로그램을 MIPS 어셈블리 코드로 번역하면

```jsx
leaf_example:
  addi $sp, $sp, -12    # 스택에 세 워드를 저장할 자리를 만들기위해 스택 포인터를 내림
		               # 아래 세 줄에서는 이 공간에 세 레지스터를 각각 저장
  sw   $t1, 8($sp)     # $t1을 스택 [$sp + 8]에 저장
  sw   $t0, 4($sp)     # $t0를 스택 [$sp + 4]에 저장
  sw   $s0, 0($sp)     # $s0를 스택 [$sp + 0]에 저장

  add $t0, $a0, $a1    # $t0 = g + h
  add $t1, $a2, $a3    # $t1 = i + j
  sub $s0, $t0, $t1    # $s0 = (g + h) - (i + j)
  add $v0, $s0, $zero  # 최종결과를 f에 저장하기위해 $s0를 $v0에 전달

  lw   $s0, 0($sp)     # $s0를 복구
  lw   $t0, 4($sp)     # $t0를 복구
  lw   $t1, 8($sp)     # $s1를 복구
  addi $sp, $sp, 12    # 스택 포인터를 되돌려놓음

  jr   $ra             # 복귀주소로 돌아감
```

메모리, 레지스터에 값을 저장했다 복구하는 과정이 https://youtu.be/gbHagOGOfLc 에 비슷한 예제를 통해 잘 설명되어 있다!



### Example2

------------------------

```
int fact(int n)
{
	if (n < 1) return (1);
		else return (n * fact(n-1));
}
```

인수 n은 레지스터 $s0에 해당한다. 

caller는 $ra와 $s0를 스택에 저장하고, temp register $t0은 저장하지 않는다. 

위 프로그램을 어셈블리 코드로 변환하면

```
fact:
	slti 	$t0, $a0, 1		# $n < 1이면 $t0 = 1, 아니면 $t0 = 0
	beq 	$t0, $zero, L1  # $t0이 제로면(n>=1이면), go to L1
	addi 	$v0, $zero, 1	# V0 = 1
	jr 		$ra				# return to caller
L1:
	addi 	$sp, $sp, -8	# 스택에 두 워드를 저장할 자리를 만들기 위해 포인터를 내림
	sw 		$ra, 4($sp)		# $ra를 [$sp+4]에 저장
	sw 		$s0, 0($sp)		# $s0를 [$sp]에 저장
	
	addi 	$a0, $a0, -1	# n >= 1이면 인수가 n-1이 됨
	jal 	fact			# 인수 (n-1)을 가지고 fact를 호출
	
	lw 		$s0, 0($sp)		# $s0 복구
	lw 		$ra, 4($sp)		# $ra 복구
	addi 	$sp, $sp, 8		# 스택 포인터를 되돌려놓음
	
	mul 	$v0, $s0, $v0	# return n*fact(n-1)
	jr		$ra				# return to caller
```

