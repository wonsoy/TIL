### 프로시저의 실행 단계

------

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
2. 프로시저로 제어를 넘긴다.
3. 프로시저가 사용할 수 있는 메모리 자원을 확보한다.
4. 프로시저를 실행한다.
5. 프로시저를 호출한 프로그램이 접근할 수 있는 곳에 결과값을 넣는다.
6. 프로시저를 호출한 프로그램에게 제어를 넘겨준다.



- MIPS는 다음의 관례에 따라 32개의 레지스터를 할당한다.

  - $a0 - $a3: 인풋 파라미터
  - $v0, $v1: 반환값
  - $ra: 호출한 곳으로 다시 되돌아가기위한 주소

  

### jal 명령어(Jump-and-link instruction)

------

지정된 주소로 jump하고 다음 명령어의 주소를 $ra레지스터에 저장한다.

```jsx
jal addr
```

jump: 지정된 주소로 점프한다.

link: 프로시저 종료 후 프로시저가 호출된 위치로 다시 돌아올 수 있도록 호출한 곳과 프로시저 사이에 링크를 형성한다. 링크는 $ra 레지스터에 저장되며, 저장된 링크를 **복귀주소(return address)**라고 한다.

```jsx
jr $ra    #$ra에 저장된 주소로 점프하라 
```

**호출 프로그램(caller)**는 $a0 - $a3에 인풋 파라미터를 넣은 후 jr 명령을 통해 프로시저인 **피호출 프로그램(callee)**을 호출한다. 피호출 프로그램은 작업을 수행하고 계산 결과를 $v0, $v1에 넣은 후 jr $ra 명령을 통해 원래 프로그램으로 복귀한다.

jal 명령은 프로시저에서 복귀할 때 다음 명령어부터 실행하도록 PC+4를 $ra에 저장한다. PC(program counter)란 현재 수행 중인 명령어의 주소를 기억하는 레지스터이다.

### 스택(Stack)

------

스택: 나중에 들어간 값이 먼저 나오는 큐.

스택포인터($sp): 가장 최근에 스택에 할당된 주소를 가리킴. 레지스터 값이 스택에 저장되거나 복구될 때마다 한 워드씩 조정됨.

push: 스택에 데이터 넣기

pop: 스택에서 데이터 빼기

스택은 높은 주소에서 낮은 주소로 성장한다. 따라서 스택에 푸시할 때는 포인터 값을 감소시켜야 하고, 팝을 할 때는 포인터 값을 증가시켜야 한다.



### Example

------

```jsx
int leaf_example(int g, int h, int i, ing j)
{
	int f;
	f = (g + h) - (i + j);
	return f;
}
```

파라미터 g, h, i, j는 각각 $a0, $a1, $a2, $a3에 해당하고 f는 $s0에 해당한다.

위 프로그램을 MIPS 어셈블리 코드로 번역하면

```jsx
leaf_example:
  addi $sp, $sp, 12    # 스택에 세 워드를 저장할 자리를 만들기위해 스택 포인터를 내림
		               # 아래 세 줄에서는 이 공간에 세 레지스터를 각각 저장
  sw   $t1, 8($sp)     # $t1을 스택 [$sp + 8]에 저장
  sw   $t0, 4($sp)     # $t0를 스택 [$sp + 4]에 저장
  sw   $s0, 0($sp)     # $s0를 스택 [$sp + 0]에 저장

  add $t0, $a0, $a1    # $t0 = g + h
  add $t1, $a2, $a3    # $t1 = i + j
  sub $s0, $t0, $t1    # $s0 = (g + h) - (i + j)
  add $v0, $s0, $zero  # 최종결과를 f에 저장하기위해 $s0를 $v0에 전달

  lw   $s0, 0($sp)     # $s0를 복구
  lw   $t0, 4($sp)     # $t0를 복구
  lw   $t1, 8($sp)     # $s1를 복구
  addi $sp, $sp, 12    # 스택 포인터를 되돌려놓음

  jr   $ra             # 복귀주소로 돌아감
```

메모리, 레지스터에 값을 저장했다 복구하는 과정이 https://youtu.be/gbHagOGOfLc 에 비슷한 예제를 통해 잘 설명되어 있다!